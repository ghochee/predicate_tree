#ifndef TREE_PREDICATED_TREE_H
#define TREE_PREDICATED_TREE_H

#include <functional>
#include <optional>

// Instantiated classed of 'predicated_tree' are used for creating objects
// which are used for constructing and efficiently using 'Predicated Trees'.
//
// Predicated Trees are trees which also uphold upto two predicates. They are
// analogous to 'std::set' class-objects which are given to uphold a predicate
// of ordering (SWO comparator which defaults to std::less). Predicated trees
// uphold two possibly orthogonal properties for ordering. One property is
// upheld as a heap-like partial ordering. A second property is upheld as a
// left-right (in-order traversal) property. More specifically:
// - inorder traversal of the tree gives values increasing in 'L' predicate.
// - max-heap-like property is maintained over the 'H' predicate.
//
// The specification of the properties to be upheld is done by a Comparator
// class of which we may take an object or default construct one. See
// comparator.h notes for more details on the predicates and why it's more
// implementation and usage difficult to use the predicates directly than to
// wrap them in the comparator.
//
// Examples:
//
//   Value type: complex number
//   Height predicate: greater imaginary component.
//   Left predicate: left-right sorted on real component.
//
//   Value type: struct of person (double height, double weight)
//   Height predicate: greater 'height'
//   Left predicate: sorted on increasing 'weight'
//
// Shape Uniqueness (aside)
//
// If both H and L are total orderings (viz. exactly one of P(a, b) or P(b, a)
// is true) then given a set of unique values the tree shape generated by this
// data structure is unique. Intuitively the proof of this is as follows:
//
// Given v0, v1, v2 unique values in order of height (v0 taller than v1 taller
// than v2). This does not lose us generality because we haven't said anything
// about their left-ordering and given any three values there will always be a
// tallest and a second tallest value. There are 6! sequences possible on
// left-right ordering of v0, v1, v2. The generated shapes for each are as
// follows (a>b means a is left of b):
//
// v0>v1>v2         v0                  v0>v2>v1         v0
//                   |                                    |
//                   -----v1                              -----v1
//                         |                                    |
//                         -----v2                        v2-----
//
//
// v1>v0>v2         v0                  v1>v2>v0         v0
//                   |                                    |
//             v1---------v2                        v1-----
//                                                   |
//                                                   -----v2
//
//
// v2>v0>v1         v0                  v2>v1>v0         v0
//                   |                                    |
//             v2---------v1                        v2-----
//                                                   |
//                                                   -----v1
//
// Other than the listed arrangements no other arrangement is possible which
// maintains the properties. Note also that when the tallest value is in the
// middle in the left-ordering (v1>v0>v2 and v2>v0>v1) the height ordering
// between v1 and v2 is lost. This is fine because height property correctness
// is only tested from a node through it's ancestors till the root.
//
// Given the above and a list of values v0, v1, ..., vN for all three
// consecutive values, exactly one of the above arrangements can be done. Note
// that when a node has to be on the right (or left) child of another node as
// described above, this really means that the node must be in the right (or
// left) *sub-tree*. Each node is part of three consecutive-triples and since
// the child can be anywhere in a subtree, each nodes position can be 'fixed'
// to meet all requirements simultaneously.
//
// Additional notes
//
// Indifferent predicates are ones which always return false (they don't
// describe any real ordering). If the Height predicate is indifferent then the
// tree is a binary search tree with L property. If the Left predicate is
// indifferent then the tree is a heap with H-max property.
//
// Equality
//
// Values are 'equal' on a predicate if P(a, b) and P(b, a) are both false.
// Values can be H-equal, L-equal or just equal if they are equal on both H and
// L. The following additional constraints ensure uniqueness of shape when
// certain equal value nodes are present in the tree.
//
// L-equal values form a left-sided parent child relation i.e. if a node is
// L-equal to another node, then the shorter node must be in the left subtree
// of the taller node.
//
// Equal nodes are constructed in the following way.
//
// - Exactly two equal nodes are arranged as parent 'p' and left child 'lc' .
//   All left-shorter nodes will end up in the left-subtree of lc. All
//   right-shorter nodes will end up in the right-subtree of p.
// - All subsequent equal value nodes are inserted as the right subtree of
//   'lc'.
//
// This above constraint ensures that searches for values don't have to
// navigate through multiple subtrees.
template <class T, class Comparator>
class predicated_tree {
  public:
    explicit predicated_tree(const Comparator = Comparator());

    // The following two methods are equivalent to the following:
    // - Disregard the height property of 'value'.
    // - Navigate to the leaf node to which value would attach using only
    //   left-ness.
    // - Consider the ancestry path P starting from this leaf node to the root
    //   traced through parent pointers.
    //
    // P is a non-decreasing-in-height sequence of values.
    // 'lower_bound' is the equivalent of lower_bound(value) on the sequence P.
    // 'upper_bound' is the equivalent of upper_bound(value) on the sequence P.
    //
    // lower_bound is also lower (in height) than the upper_bound which is
    // higher (in height).
    //
    // Similar to STL bounds, lower_bound == upper_bound if value is absent.
    // [lower_bound, upper_bound) form an 'equal' range. Note that inorder
    // traversal from lower_bound through upper_bound will give all the
    // equal-valued nodes. Note that this guarantee is met even if nodes are
    // not constructed as described in class description (right subtree of
    // lower_bound being all equal nodes). If all equal nodes form a left
    // leaning chain the bounds and in-order traversal properties will still be
    // correct.
    //
    // NOTE: There is an important difference between lower_bound in standard
    // STL sequences and lower_bound here. In STL sequences lower_bound is
    // reached first from the search start point (::begin typically). Here the
    // upper_bound is encountered first.
    //
    // Complexity:
    //   O(lg(N)).
    accessor<const raw_tree<T>> upper_bound(const T &value) const;
    accessor<const raw_tree<T>> lower_bound(const T &value) const;
    // Same as above but returns 'end' if 'value' is not found in the tree.
    accessor<const raw_tree<T>> find(const T &value) const;

    // Insert 'value' into a tree. 'pos' is a hint for the location where we
    // might start our search. If 'pos' is incorrect, insertion is still done
    // at the right location but with an extra cost.
    // Complexity:
    //   O(lg(N)).
    accessor<const raw_tree<T>> insert(
        T &&value,
        accessor<const raw_tree<T>> hint = accessor<const raw_tree<T>>());
    // Insert 'start' and 'end' range of iterators at 'pos' or subtree of 'pos'.
    // Complexity:
    //   O(D * lg(N + D)) where D is std::distance(start, end).
    template <typename It>
    accessor<const raw_tree<T>> insert(
        It begin, It end,
        accessor<const raw_tree<T>> pos = accessor<const raw_tree<T>>());

    // Erase the element pointed to by 'pos'. No-op if 'pos' is 'end'.
    // Complexity:
    //   O(lg(N)).
    void erase(accessor<const raw_tree<T>> pos);

    // Removes all values from the tree.
    void clear();

    // Get the value at root.
    const T &operator*() const;

    // Return a pointer to the underlying tree root for performing operations.
    const raw_tree<T> *operator->() const;

    // Releases ownership of the underlying tree to the call site. This is the
    // only way to get a mutable reference to the underlying tree. This ensures
    // client code cannot meddle with the tree while it is under the care of
    // 'predicated_tree'.
    raw_tree<T> release();

  private:
    ::std::optional<raw_tree<T>> tree_;
    mutator<T, Comparator> mutator_;
};

#include "tree/predicated_tree.hh"

#endif  // TREE_PREDICATED_TREE_H
